!===============================================================================
!                                                                                
! NAME:                                                                          
!                   -------- MUSSOL v2: MAIN PROGRAM --------                     
!                                                                                
! AUTHOR:
!       Dr. Manel Perucho Pla
!       Astronomy and Astrophysics Department, University of Valencia
!       46100, Burjassot (Valencia)
!
! MODIFICATIONS:                                                                 
!       Kiara Hervella Seoane
!       Astronomy and Astrophysics Department, University of Valencia
!       46100, Burjassot (Valencia)
!
! DESCRIPTION:
!       MAIN PROGRAM: Analysis and post-processing of RATPENAT hdf5 outputs.
!                     HYBRID OMP+MPI PARALLELIZATION.
!
! ACADEMIC REFERENCE:
!       Academic references in subroutines.
!
!===============================================================================

      Program MUSSOL

! Including external modules and libraries 
      USE tipos
      USE memoria
      USE parallel
      USE workarrays

#ifdef TIEMPO
      USE tiempo
#endif

#if defined(PARALELO)
      USE mpi
#endif
      IMPLICIT NONE

# include "types.h"

!-------------------------------------------------------Local Variables

      logical(ls):: NoSalir, NoEixir

      integer(is) :: part,ndirs,freqpl,final,H_openr,H_opend, &
                     rst_file,rst_rec,rst_filed,curR_R,freq,  &
                     r_filer, r_filed, mpi_coordx, mpi_coordy, mpi_coordz

      character(20) :: ndirsch
      character(8)  :: datfil
      character(7)  :: rstfil, rstfila, outfil, tdlfil
      character(10) :: results
      character(4)  :: basenm
      character(3)  :: suffixd
      character(2)  :: suffix

!     Local sizes for nx, ny, nz
!     nyh -> Global homogeneous size
!     nyt -> Global size
!     nyold -> used for restart and increase of grid

      integer(is):: nx, nx2, nxo, &
      nz, nz2, nzo,               &
      ny, nny, ny0, nyold, nyh, nys, nyt, &
      imin, imax, jmin, jmax, kmin, kmax, &
      nxtot, nytot, nztot

      integer(is):: dxoff, dyoff, dzoff, lon

!     Local & maximum sizes for workarrays (+1, +5, and +6)
      integer(is):: mnx1, mnx5, mnx6, &
      mny1, mny5, mny6, &
      mnz1, mnz5, mnz6, &
      mn1,  mn5,  mn6

      integer(is):: ierr, ii, jj, kk, ll, mm, qq,     &
      xyswp, nbegin, iwrtd, rkin,                     &
      igeomx, igeomy, igeomz,                         &
      bndmnx, bndmxx, bndmny, bndmxy, bndmnz, bndmxz, &
      nend, irstrt, nrstrt, nout, iapprs, irk, igodu, &
      itstp, niter, nsdim, nmod,                      &
      ixsym, izsym, iextrax, iextraz,                 &
      nstep, nout1, nrst, itdelay, ipr, ms, mclouds,  &
      brt
      
      real(rs)   :: alpha_R, beta_R, timed, dtimed,    &
      gamma_ad, alpha, tmax, trstrt, tout, cfl, dtini, &
      small, smlrho, smallp, smallu,                   &
      gridlx, gridlx2, gridly, gridlz,                 &
      gridlz2, epsiln, omg1, omg2,                     &
      delx, dely, delz, temb,                          &
      pb, rhob, rhoeb, velb, machb, gamb, csb2,        &
      dk1, dk2, psh1, psh2, mm1, mm2,                  &
      nn, oang, t0, t1, vptbd, rptbd, pptbd,           &
      gamma_e, gamma_c, gamma_ce,                      &
      eps_e, eps_c, rho_e, rho_c, p_e, p_c, w_c,       &
      nu_ce, xd, timej, dt, tout1, trst,               &
      alpn, betn, gamn, rbn, radius, cdenst,           & 
      q0, mloss0, fg, rm, tem0, tem1, epsb, hb, lofb,  &
      lk, me, mp
      
      real(rs)   :: pc, me_cgs, c, mp_cgs, R_b, rho_0a, m_0, kb, meff, &
      KB1, KB2, pi, shift

      real(rs)   :: en_inj_jj, en_inja(8)
      real(rs), allocatable:: en_inj(:)

      type(Tint), allocatable:: intarrayx(:)
      
      type(Tint), allocatable:: intarrayz(:)

      type(Tint), allocatable:: intarrayy(:)

      type(Tint), allocatable:: arrayt(:), arrayg(:), arrayw(:)
      
      real(rs), allocatable:: xznl(:), xzn(:), xznr(:), &
                              yznl(:), yzn(:), yznr(:), &
                              zznl(:), zzn(:), zznr(:), &
                              grav(:), rhoa(:),         &
                              pa(:), dpady(:)

      real(rs), allocatable:: shpos(:),ph(:), &
                              shposg(:),shposgt(:),phig(:)

      real(rs), allocatable:: mass_ent(:)!, ent_pj(:), ent_pa(:), ent_tot(:)                        

      type(Tphysic), allocatable:: physic(:,:,:), physica(:,:,:)
      
      real(rs):: shposi, phi, vel, shpostx, ratio
      
      real(rs), allocatable:: shposa(:,:), shpost(:,:), phia(:,:)

      integer :: omp_get_num_threads, omp_get_max_threads, curth

      integer :: ofznx, onznx, ofzny, onzny, ofznz, onznz

      integer :: numArgs, xCPUs, yCPUs, zCPUs 

      character(len=256) :: program_name, tmpStr
      
      real(rs):: dvol

      real(rs):: potc, rj, psc, xe, xea, ri, epot0f

      real(rs):: entpaof, enintaof, massaof, ze, zp,   &
           meff1, dpdrho, geb, gpb, dge, dgp, np, time_prev, &
           deltay, npa, csa

      
      real(rs):: countp, countpco, nci, countt

      integer(is):: count_frames, sz, szi, sziw, nodes, nv, ng, &
                    szii, nsh

      integer(is), allocatable:: disp(:,:,:), dispco(:,:,:), kk2(:,:)

      real(rs), allocatable:: tem(:,:,:), tema(:,:,:), gam(:,:,:), gama(:,:,:), &
                              hr(:,:,:), lof(:,:,:), phs(:,:), rhoa0(:), presa0(:), &
                              epsa0(:), gama0(:), tema0(:)


      integer(is):: rpos, count1, ir, op, counti, countj, countk, jjp

      real(rs):: hmin, erro, h1, ystart(1),x1,x2,yp(1,1001),ys

      real(rs):: deltaen, deltaen2, deltaen3, en_inj_tot, tau_inj_tot, &
                 taud_inj_tot, lxevol, scr

      integer(is):: nvar, nok, nbad, kount, number

!--------------------------------------------------------------------------BEGIN
      
      ! Constants
      pc = 1 / 3.24254215e-19  ! Parsec in cm
      me_cgs = 9.1095e-28 ! Electron mass in g
      c = 2.99792458e10 ! Speed of light in cm/s
      kb = 1.38066e-16
      mp_cgs = 1836.11 * me_cgs
      KB1 = 7.5e20 !1.4e-27!
      ! KB1 = KB1*mp_cgs**2/1.12
      KB2 = 4.4e-10
      kb = 1.38066e-16
      csa = 2.3e-3 ! Speed of sound

      ! Parameters
      pi = acos(-1.0)      
      number = 0
      hmin = 5.
      erro=1.e-3
      h1 = 10. 
      
      ! ------------------------------------------- INPUTS

      ! Process the command line
      outRoot =''
      path_wkd =''
      path_output =''
      numArgs = command_argument_count()

      call get_command_argument(0, program_name)
      if (numArgs.ne.6) then
         print*, 'Usage: ', TRIM(program_name), &
         'OutRoot, Working-Path xCPUS yCPUS zCPUS'
         STOP ' '
      endif
      call get_command_argument(1, outRoot)
      call get_command_argument(2, path_wkd)
      call get_command_argument(3, path_output)
      call get_command_argument(4, tmpstr)
      read(tmpstr, *) xCPUs
      call get_command_argument(5, tmpstr)
      read(tmpstr, *) yCPUs
      call get_command_argument(6, tmpstr)
      read(tmpstr, *) zCPUs

      ! Get number of nodes
      nodes = xCPUs*yCPUs*zCPUs

      ! Read initial parameters
      call input( suffix, suffixd, basenm, rst_file, rst_rec,  &
      nend, irstrt, nrstrt, nout, itstp, iapprs,        &
      irk, igodu, niter, nsdim, ixsym, izsym,           &
      iextrax, iextraz, nx, nx2, nxo, ny, nyold, nyh,   &
      nz, nz2, nzo, mnx1, mnx5, mnx6, mnz1, mnz5, mnz6, &
      igeomx, igeomy, igeomz,                           &
      xd, alpha, tmax, trstrt, tout, cfl, dtini,        &
      small, smlrho, smallp, smallu,                    &
      gridlx, gridlx2, gridlz, gridlz2, gridly,         &
      epsiln, omg1, omg2, freqpl)

      ! Read initial parameters for the environment and the jet
      itdelay = 0
      call input_j(  basenm,                                           &
               suffixd, tdlfil, itdelay, gamma_ad, velb, rhob, rhoeb,  &
               temb, machb, radius, cdenst, shift, q0, fg, ms,         &
               dk1, dk2, rm, psh1, psh2, nn, mm1, mm2, ipr,            &
               alpn, betn, gamn, rbn, brt, tem0, tem1, oang, csb2,     &
               pb, mclouds, t0, t1, vptbd, rptbd, pptbd)

      ! h5 snapshots file names and count
      rstfila = basenm//'I'//suffix
      rstfil  = basenm//'R'//suffix
      call snapshot_count(outRoot,rstfil,sz)
      ! Reading frequency
      freq = 1

      ! ------------------------------------------- Code units

      R_b    = radius * pc
      rho_0a = cdenst*mp_cgs
      m_0    = rho_0a * R_b**3
      me     = me_cgs / m_0
      mp     = mp_cgs / m_0
      psh1   = psh1*pc/R_b
      psh2   = psh2*pc/R_b 
      rm     = rm*pc/R_b
      rbn    = rbn*pc/R_b
      shift  = shift*pc/R_b    
      temb   = temb*kb/(m_0*c**2)

      ! ------------------------------------------- MPI & OMP initialitation

      call mpi_init3D (xCPUs, yCPUs, zCPUs, nsdim)
      !   print*, ' MAIN:  after MPI_INIT'
      !    call flush(6)
      call omp_init
      !   print*, ' MAIN:  after OMP_INIT'
      !    call flush(6)
      call distribute_ompth (nsdim) 
      !   print*, ' MAIN:  after DISTRIBUTE OMPTH'
      !    !call flush(6)
      call decompose_mpi_domain (xCPUs, yCPUs, zCPUs, nx, ny, nz, nx2, nz2, nyold, nyh)
      !   print*, ' MAIN:  after DECOMPOSE_MPI_DOMAIN'
      !    !call flush(6)
      
      ! ny is going to be the total size of a local grid
      ! ny0 is the homogeneous size of the local grid (used with growing jets)
      
      ! Split of the grid between the parallelized nodes
      call reparto_trabajo( basenm, nx*xCPUs, ny*yCPUs, nz*zCPUs, mn1, mn5, mn6, mnx1, mnx5, mnx6, &
      mny1, mny5, mny6, mnz1, mnz5, mnz6, ny0 )
      
      ! -------------------------------------------  Allocation of grid, boundary and physical variables
      
      allocate( xznl(mnx1), xzn(mnx1), xznr(mnx1),    &
      yznl(mny1), yzn(mny1), yznr(mny1),              &
      zznl(mnz1), zzn(mnz1), zznr(mnz1),              &
      grav(-4:mny5), rhoa(-4:mny5),                   &
      pa(-4:mny5), dpady(-4:mny5), intarrayx(mnx1),   &
      intarrayz(mnz1), intarrayy(mny1), arrayt(1),    &
      arrayg(nodes), arrayw(sz), stat=ierr )
      allocate(shpos(sz),ph(sz),shposg(nodes),shposgt(nodes),phig(nodes),stat=ierr)
      allocate(disp(mnx1,mny1,mnz1), dispco(mnx1,mny1,mnz1), kk2(nx,nz),stat=ierr)
      allocate(tem(mnx1,mny1,mnz1), tema(mnx1,mny1,mnz1), gam(mnx1,mny1,mnz1), gama(mnx1,mny1,mnz1), &
               hr(mnx1,mny1,mnz1), lof(mnx1,mny1,mnz1), phs(nx,nz), shposa(mnx1,mnz1), &
               phia(mnx1,mnz1), shpost(mny1,mnz1), rhoa0(mnx1), tema0(mnx1),   &
               presa0(mnx1), epsa0(mnx1), gama0(mnx1), stat=ierr)
      allocate(mass_ent(sz), en_inj(sz), stat=ierr) ! ent_pj(sz), ent_pa(sz), ent_tot(sz),stat=ierr)

      if (ierr /= 0) then
         print*, 'Main ERROR. Allocation of main variables xznl'
      endif

      allocate( physica(-4:mnx5,-4:mny5,-4:mnz5), stat=ierr )
      allocate( physic(-4:mnx5,-4:mny5,-4:mnz5), stat=ierr )

      if (ierr /= 0) then
         print*, 'Main ERROR. Allocation of main variable physic', ierr, cartrank
      endif

#ifdef HDF
      call rrhdf5_init(H_openr, H_opend)
#endif  
       
      ! Nodes grid points
      imin  = mpi_coords(1) * nx       
      jmin  = mpi_coords(2) * ny       
      kmin  = mpi_coords(3) * nz

      ! Parameters for the gathering
      nvar = 1
      ! npar = 54 already defined in moduled TIPO
      nv = npar
      ng = npar*nodes      

      ! Loop over the snapshots: for each saved time
      if (cartrank == 0) then
         print*,''
         print*,'MUSSOL: analisying results of simulation ', basenm
         print*,''
      endif

      !------------------------------------------------------- Ambient/environment

      if (cartrank==0) then
         print*,''
         print*, 'Reading initial ambient data'
         print*,''
      endif

      ! Read the snapshot file
      call rst_hdf5( rst_file, rst_rec, rstfila, freq,               &
      basenm, mnx1, mnx5, mny1, mny5, mnz1, mnz5,                    &
      H_openr, H_opend, r_filer, r_filed,                            &
      gamma_ad, xzn, yzn, zzn, timej, dt,                            &
      bndmnx, bndmxx, bndmny, bndmxy, bndmnz, bndmxz,                &
      gridlx, gridly, gridlz, nx, ny, ny0, nyold, nz, nsdim,         &
      nxo, nzo, nstep, igeomx, igeomy, igeomz,                       &
      mpi_coordx, mpi_coordy, mpi_coordz,                            &
      pb, rhob, rhoeb, velb, temb, machb, csb2, dk1, dk2,            &      
      psh1, psh2, mm1, mm2, nn, tem0, tem1, alpn, betn, gamn, rbn,   &
      radius, cdenst, shift, fg, rm, brt, me, mp,                    &
      m_0, R_b, c, pc, rho_0a, q0, oang, ipr, ms, nmod,              &
      t0, t1, vptbd, rptbd, pptbd, grav, rhoa, pa, physica)

      ! Share boundary cells data
      call intercambiaBoundPhysic( physica, nx, ny, nz, mnx5, mny5, mnz5, bndmny, bndmxy )

      ! Saving grid data per node
      if ( mpi_coords(1) == (mpi_dims(1)-1) ) then
         do kk= 1, nz       
            do jj= 1, ny  
               physica(nx+1,jj,kk)%denstye= physica(nx,jj,kk)%denstye
               physica(nx+1,jj,kk)%densty=physica(nx,jj,kk)%densty
               physica(nx+1,jj,kk)%eps=physica(nx,jj,kk)%eps
               physica(nx+1,jj,kk)%pres= physica(nx,jj,kk)%pres
               physica(nx+1,jj,kk)%velx=physica(nx,jj,kk)%velx
               physica(nx+1,jj,kk)%vely=physica(nx,jj,kk)%vely
               physica(nx+1,jj,kk)%velz= physica(nx,jj,kk)%velz
               physica(nx+1,jj,kk)%tracer=physica(nx,jj,kk)%tracer
            enddo
         enddo
      endif

      if ( mpi_coords(2) == (mpi_dims(2)-1) ) then
         do kk=1,nz
            do ii=1,nx
               physica(ii,ny+1,kk)%denstye= physica(ii,ny,kk)%denstye
               physica(ii,ny+1,kk)%densty=physica(ii,ny,kk)%densty
               physica(ii,ny+1,kk)%eps=physica(ii,ny,kk)%eps
               physica(ii,ny+1,kk)%pres= physica(ii,ny,kk)%pres
               physica(ii,ny+1,kk)%velx=physica(ii,ny,kk)%velx
               physica(ii,ny+1,kk)%vely=physica(ii,ny,kk)%vely
               physica(ii,ny+1,kk)%velz= physica(ii,ny,kk)%velz
               physica(ii,ny+1,kk)%tracer=physica(ii,ny,kk)%tracer                   
            enddo
         enddo
      endif

      if ( mpi_coords(3) == (mpi_dims(3)-1) ) then
         do jj=1,ny
            do ii=1,nx
               physica(ii,jj,nz+1)%denstye= physica(ii,jj,nz)%denstye
               physica(ii,jj,nz+1)%densty=physica(ii,jj,nz)%densty
               physica(ii,jj,nz+1)%eps=physica(ii,jj,nz)%eps
               physica(ii,jj,nz+1)%pres= physica(ii,jj,nz)%pres
               physica(ii,jj,nz+1)%velx=physica(ii,jj,nz)%velx
               physica(ii,jj,nz+1)%vely=physica(ii,jj,nz)%vely
               physica(ii,jj,nz+1)%velz= physica(ii,jj,nz)%velz
               physica(ii,jj,nz+1)%tracer=physica(ii,jj,nz)%tracer    
            enddo
         enddo
      endif

      if ( mpi_coords(1) == (mpi_dims(1)-1) .and. mpi_coords(3) == (mpi_dims(3)-1) ) then
         do jj= 1, ny
               physica(nx+1,jj,nz+1)%denstye= physica(nx+1,jj,nz)%denstye
               physica(nx+1,jj,nz+1)%densty=physica(nx+1,jj,nz)%densty
               physica(nx+1,ny+1,kk)%eps=physica(nx+1,ny,kk)%eps
               physica(nx+1,jj,nz+1)%pres= physica(nx+1,jj,nz)%pres
               physica(nx+1,jj,nz+1)%velx=physica(nx+1,jj,nz)%velx
               physica(nx+1,jj,nz+1)%vely=physica(nx+1,jj,nz)%vely
               physica(nx+1,jj,nz+1)%velz= physica(nx+1,jj,nz)%velz
               physica(nx+1,jj,nz+1)%tracer=physica(nx+1,jj,nz)%tracer
         enddo
      endif

      if ( mpi_coords(2) == (mpi_dims(2)-1) .and. mpi_coords(3) == (mpi_dims(3)-1) ) then
            do ii=1,nx
               physica(ii,ny+1,nz+1)%denstye= physica(ii,ny+1,nz)%denstye
               physica(ii,ny+1,nz+1)%densty=physica(ii,ny+1,nz)%densty
               physica(ii,ny+1,kk)%eps=physica(ii,ny,kk)%eps
               physica(ii,ny+1,nz+1)%pres= physica(ii,ny+1,nz)%pres
               physica(ii,ny+1,nz+1)%velx=physica(ii,ny+1,nz)%velx
               physica(ii,ny+1,nz+1)%vely=physica(ii,ny+1,nz)%vely
               physica(ii,ny+1,nz+1)%velz= physica(ii,ny+1,nz)%velz
               physica(ii,ny+1,nz+1)%tracer=physica(ii,ny+1,nz)%tracer
            enddo
      endif

      if ( mpi_coords(1) == (mpi_dims(1)-1) .and. mpi_coords(2) == (mpi_dims(2)-1) ) then
            do kk=1,nz
               physica(nx+1,ny+1,kk)%denstye= physica(nx,ny+1,kk)%denstye
               physica(nx+1,ny+1,kk)%densty=physica(nx,ny+1,kk)%densty
               physica(ii,jj,nz+1)%eps=physica(ii,jj,nz)%eps
               physica(nx+1,ny+1,kk)%pres= physica(nx,ny+1,kk)%pres
               physica(nx+1,ny+1,kk)%velx=physica(nx,ny+1,kk)%velx
               physica(nx+1,ny+1,kk)%vely=physica(nx,ny+1,kk)%vely
               physica(nx+1,ny+1,kk)%velz= physica(nx,ny+1,kk)%velz
               physica(nx+1,ny+1,kk)%tracer=physica(nx,ny+1,kk)%tracer
            enddo
      endif

      ! Share row cells data
      call intercambiaRow( physica, nx, ny, nz, mnx5, mny5, mnz5)

      call MPI_BARRIER( MPI_COMM_WORLD, ierr )

      call intercambiaRow( physica, nx, ny, nz, mnx5, mny5, mnz5)

      if ( mpi_coords(1) == (mpi_dims(1)-1) .or. mpi_coords(2) == (mpi_dims(2)-1) &
            .or.mpi_coords(3) == (mpi_dims(3)-1) ) then
               physica(nx+1,ny+1,nz+1)%denstye= physica(nx+1,ny+1,nz)%denstye
               physica(nx+1,ny+1,nz+1)%densty=physica(nx+1,ny+1,nz)%densty
               physica(nx+1,ny+1,nz+1)%eps=physica(nx+1,ny+1,nz)%eps
               physica(nx+1,ny+1,nz+1)%pres= physica(nx+1,ny+1,nz)%pres
               physica(nx+1,ny+1,nz+1)%velx=physica(nx+1,ny+1,nz)%velx
               physica(nx+1,ny+1,nz+1)%vely=physica(nx+1,ny+1,nz)%vely
               physica(nx+1,ny+1,nz+1)%velz= physica(nx+1,ny+1,nz)%velz
               physica(nx+1,ny+1,nz+1)%tracer=physica(nx+1,ny+1,nz)%tracer
      endif


!$OMP PARALLEL DEFAULT(shared)&  
!$OMP PRIVATE(ii,jj,kk,xe,ze,zp,meff1,dpdrho,geb,gpb,dge,dgp,scr)
!$OMP DO SCHEDULE(static)

      !Compute other variables
      do kk= 1, nz+1        
         do jj= 1, ny+1 
            do ii= 1, nx+1 
                    
               xe=physica(ii,jj,kk)%denstye/physica(ii,jj,kk)%densty
               meff1 = (1.0-xe)/mp + xe/me
               tema(ii,jj,kk)=physica(ii,jj,kk)%pres/meff1/(physica(ii,jj,kk)%densty)

               ze = me / tema(ii,jj,kk)
               zp = mp / tema(ii,jj,kk)
               dpdrho = tema(ii,jj,kk)*meff1

               geb = 5.0/2.0/ze+sqrt(9.0/4.0/ze**2+1.0)
               gpb = 5.0/2.0/zp+sqrt(9.0/4.0/zp**2+1.0)
               dge = -5.0/2.0/ze**2-9.0/4.0/ze**3/  &
                     sqrt(9.0/4.0/ze**2+1.0)
               dgp = -5.0/2.0/zp**2-9.0/4.0/zp**3/  &
                     sqrt(9.0/4.0/zp**2+1.0)
               
               physica(ii,jj,kk)%eps = (1.0-xe)*gpb + xe*geb - dpdrho - 1.0
               gama(ii,jj,kk) = 1. - 1./(1.+( (1.-xe)*dgp*zp**2/mp +  &
                     xe*dge*ze**2/me )/meff1)

               ! Temperature to cgs units
               tema(ii,jj,kk)=physica(ii,jj,kk)%pres*(c**2)*rho_0a/(xe/me_cgs+(1-xe)/mp_cgs)/ &
                     (kb*physica(ii,jj,kk)%densty*rho_0a)
            
            enddo  
         enddo
      enddo

!$OMP END DO
!$OMP END PARALLEL

      !------------------------------------------------------- Jet evolution

      DO szi = 0, sz !, sz

         if (cartrank == 0) then
            print*,''
            print*,'======================================= ',rst_file,' ======================================'
            print*,''
         endif

         ! Read the snapshot file
         call rst_hdf5( rst_file, rst_rec, rstfil, freq,                     &
            basenm, mnx1, mnx5, mny1, mny5, mnz1, mnz5,                    &
            H_openr, H_opend, r_filer, r_filed,                            &
            gamma_ad, xzn, yzn, zzn, timej, dt,                            &
            bndmnx, bndmxx, bndmny, bndmxy, bndmnz, bndmxz,                &
            gridlx, gridly, gridlz, nx, ny, ny0, nyold, nz, nsdim,         &
            nxo, nzo, nstep, igeomx, igeomy, igeomz,                       &
            mpi_coordx, mpi_coordy, mpi_coordz,                            &
            pb, rhob, rhoeb, velb, temb, machb, csb2, dk1, dk2,            &      
            psh1, psh2, mm1, mm2, nn, tem0, tem1, alpn, betn, gamn, rbn,   &
            radius, cdenst, shift, fg, rm, brt, me, mp,                    &
            m_0, R_b, c, pc, rho_0a, q0, oang, ipr, ms, nmod,              &
            t0, t1, vptbd, rptbd, pptbd, grav, rhoa, pa, physic)

         ! Share boundary cells data
         call intercambiaBoundPhysic( physic, nx, ny, nz, mnx5, mny5, mnz5, bndmny, bndmxy )

         ! Saving grid data per node
         if ( mpi_coords(1) == (mpi_dims(1)-1) ) then
            do kk= 1, nz       
               do jj= 1, ny  
                  physic(nx+1,jj,kk)%denstye= physic(nx,jj,kk)%denstye
                  physic(nx+1,jj,kk)%densty=physic(nx,jj,kk)%densty
                  physic(nx+1,jj,kk)%eps=physic(nx,jj,kk)%eps
                  physic(nx+1,jj,kk)%pres= physic(nx,jj,kk)%pres
                  physic(nx+1,jj,kk)%velx=physic(nx,jj,kk)%velx
                  physic(nx+1,jj,kk)%vely=physic(nx,jj,kk)%vely
                  physic(nx+1,jj,kk)%velz= physic(nx,jj,kk)%velz
                  physic(nx+1,jj,kk)%tracer=physic(nx,jj,kk)%tracer
               enddo
            enddo
         endif

         if ( mpi_coords(2) == (mpi_dims(2)-1) ) then
            do kk=1,nz
               do ii=1,nx
                  physic(ii,ny+1,kk)%denstye= physic(ii,ny,kk)%denstye
                  physic(ii,ny+1,kk)%densty=physic(ii,ny,kk)%densty
                  physic(ii,ny+1,kk)%eps=physic(ii,ny,kk)%eps
                  physic(ii,ny+1,kk)%pres= physic(ii,ny,kk)%pres
                  physic(ii,ny+1,kk)%velx=physic(ii,ny,kk)%velx
                  physic(ii,ny+1,kk)%vely=physic(ii,ny,kk)%vely
                  physic(ii,ny+1,kk)%velz= physic(ii,ny,kk)%velz
                  physic(ii,ny+1,kk)%tracer=physic(ii,ny,kk)%tracer                   
               enddo
            enddo
         endif

         if ( mpi_coords(3) == (mpi_dims(3)-1) ) then
            do jj=1,ny
               do ii=1,nx
                  physic(ii,jj,nz+1)%denstye= physic(ii,jj,nz)%denstye
                  physic(ii,jj,nz+1)%densty=physic(ii,jj,nz)%densty
                  physic(ii,jj,nz+1)%eps=physic(ii,jj,nz)%eps
                  physic(ii,jj,nz+1)%pres= physic(ii,jj,nz)%pres
                  physic(ii,jj,nz+1)%velx=physic(ii,jj,nz)%velx
                  physic(ii,jj,nz+1)%vely=physic(ii,jj,nz)%vely
                  physic(ii,jj,nz+1)%velz= physic(ii,jj,nz)%velz
                  physic(ii,jj,nz+1)%tracer=physic(ii,jj,nz)%tracer    
               enddo
            enddo
         endif

         if ( mpi_coords(1) == (mpi_dims(1)-1) .and. mpi_coords(3) == (mpi_dims(3)-1) ) then
            do jj= 1, ny
                  physic(nx+1,jj,nz+1)%denstye= physic(nx+1,jj,nz)%denstye
                  physic(nx+1,jj,nz+1)%densty=physic(nx+1,jj,nz)%densty
                  physic(nx+1,ny+1,kk)%eps=physic(nx+1,ny,kk)%eps
                  physic(nx+1,jj,nz+1)%pres= physic(nx+1,jj,nz)%pres
                  physic(nx+1,jj,nz+1)%velx=physic(nx+1,jj,nz)%velx
                  physic(nx+1,jj,nz+1)%vely=physic(nx+1,jj,nz)%vely
                  physic(nx+1,jj,nz+1)%velz= physic(nx+1,jj,nz)%velz
                  physic(nx+1,jj,nz+1)%tracer=physic(nx+1,jj,nz)%tracer
            enddo
         endif

         if ( mpi_coords(2) == (mpi_dims(2)-1) .and. mpi_coords(3) == (mpi_dims(3)-1) ) then
               do ii=1,nx
                  physic(ii,ny+1,nz+1)%denstye= physic(ii,ny+1,nz)%denstye
                  physic(ii,ny+1,nz+1)%densty=physic(ii,ny+1,nz)%densty
                  physic(ii,ny+1,kk)%eps=physic(ii,ny,kk)%eps
                  physic(ii,ny+1,nz+1)%pres= physic(ii,ny+1,nz)%pres
                  physic(ii,ny+1,nz+1)%velx=physic(ii,ny+1,nz)%velx
                  physic(ii,ny+1,nz+1)%vely=physic(ii,ny+1,nz)%vely
                  physic(ii,ny+1,nz+1)%velz= physic(ii,ny+1,nz)%velz
                  physic(ii,ny+1,nz+1)%tracer=physic(ii,ny+1,nz)%tracer
               enddo
         endif

         if ( mpi_coords(1) == (mpi_dims(1)-1) .and. mpi_coords(2) == (mpi_dims(2)-1) ) then
               do kk=1,nz
                  physic(nx+1,ny+1,kk)%denstye= physic(nx,ny+1,kk)%denstye
                  physic(nx+1,ny+1,kk)%densty=physic(nx,ny+1,kk)%densty
                  physic(ii,jj,nz+1)%eps=physic(ii,jj,nz)%eps
                  physic(nx+1,ny+1,kk)%pres= physic(nx,ny+1,kk)%pres
                  physic(nx+1,ny+1,kk)%velx=physic(nx,ny+1,kk)%velx
                  physic(nx+1,ny+1,kk)%vely=physic(nx,ny+1,kk)%vely
                  physic(nx+1,ny+1,kk)%velz= physic(nx,ny+1,kk)%velz
                  physic(nx+1,ny+1,kk)%tracer=physic(nx,ny+1,kk)%tracer
               enddo
         endif

         ! Share row cells data
         call intercambiaRow( physic, nx, ny, nz, mnx5, mny5, mnz5)

         call MPI_BARRIER( MPI_COMM_WORLD, ierr )

         call intercambiaRow( physic, nx, ny, nz, mnx5, mny5, mnz5)

         if ( mpi_coords(1) == (mpi_dims(1)-1) .or. mpi_coords(2) == (mpi_dims(2)-1) &
               .or.mpi_coords(3) == (mpi_dims(3)-1) ) then
                  physic(nx+1,ny+1,nz+1)%denstye= physic(nx+1,ny+1,nz)%denstye
                  physic(nx+1,ny+1,nz+1)%densty=physic(nx+1,ny+1,nz)%densty
                  physic(nx+1,ny+1,nz+1)%eps=physic(nx+1,ny+1,nz)%eps
                  physic(nx+1,ny+1,nz+1)%pres= physic(nx+1,ny+1,nz)%pres
                  physic(nx+1,ny+1,nz+1)%velx=physic(nx+1,ny+1,nz)%velx
                  physic(nx+1,ny+1,nz+1)%vely=physic(nx+1,ny+1,nz)%vely
                  physic(nx+1,ny+1,nz+1)%velz= physic(nx+1,ny+1,nz)%velz
                  physic(nx+1,ny+1,nz+1)%tracer=physic(nx+1,ny+1,nz)%tracer
         endif

!$OMP PARALLEL DEFAULT(shared)&  
!$OMP PRIVATE(ii,jj,kk,xe,ze,zp,meff1,dpdrho,geb,gpb,dge,dgp,scr)
!$OMP DO SCHEDULE(static)

         ! RATPENAT VARIABLES DICTIONARY
         ! densty := Density
         ! denstye := Leptonic density
         ! eps := Specific internal energy
         ! pres := Pressure
         ! velx, vely, velz := Velocities
         ! tracer := Jet particles tracer

         ! xe := Leptonic fraction
         ! tem := Temperature
         ! ze := Electron mass relative to temperature
         ! zp := Proton mass relative to temperature
         ! meff1 := Efective mass ^-1
         ! dpdrho := Derivative of pressure with respect to density

         ! geb, gpb := Bessel functions approximation
         ! dge, dgp := Derivative of Bessel functions approximation
         ! gam := Adiabatic index of the fluid
         ! hr := Specific entalphy
         ! lof := Lorentz factor

         ! en_inj_jj := Energy injected by the jet in the current node
         ! en_inja := Array of energy injected by the jet in each the node for the root node
         ! en_inj(szi) := Total energy injected by the jet in the time of snapshot szi

         !Compute other variables
         do kk= 1, nz+1        
            do jj= 1, ny+1 
               do ii= 1, nx+1 

                  xe=physic(ii,jj,kk)%denstye/physic(ii,jj,kk)%densty
                  meff1 = (1.0-xe)/mp + xe/me
                  tem(ii,jj,kk)=physic(ii,jj,kk)%pres/meff1/(physic(ii,jj,kk)%densty)

                  ze = me / tem(ii,jj,kk)
                  zp = mp / tem(ii,jj,kk)
                  dpdrho = tem(ii,jj,kk)*meff1

                  geb = 5.0/2.0/ze+sqrt(9.0/4.0/ze**2+1.0)
                  gpb = 5.0/2.0/zp+sqrt(9.0/4.0/zp**2+1.0)
                  dge = -5.0/2.0/ze**2-9.0/4.0/ze**3/  &
                        sqrt(9.0/4.0/ze**2+1.0)
                  dgp = -5.0/2.0/zp**2-9.0/4.0/zp**3/  &
                        sqrt(9.0/4.0/zp**2+1.0)
                  
                  physic(ii,jj,kk)%eps = (1.0-xe)*gpb + xe*geb - dpdrho - 1.0
                  gam(ii,jj,kk) = 1. - 1./(1.+( (1.-xe)*dgp*zp**2/mp +  &
                        xe*dge*ze**2/me )/meff1)

                  hr(ii,jj,kk) = 1.0 + physic(ii,jj,kk)%eps + dpdrho

                  ! Temperature to cgs units
                  tem(ii,jj,kk)=physic(ii,jj,kk)%pres*(c**2)*rho_0a/(xe/me_cgs+(1.-xe)/mp_cgs)/ &
                        (kb*physic(ii,jj,kk)%densty*rho_0a)
                  
                  scr = physic(ii,jj,kk)%velx*physic(ii,jj,kk)%velx
                  scr = scr + physic(ii,jj,kk)%vely*physic(ii,jj,kk)%vely
                  scr = scr + physic(ii,jj,kk)%velz*physic(ii,jj,kk)%velz

                  lof(ii,jj,kk) = 1. /sqrt(1. - scr)
                  
               enddo  
            enddo
         enddo
!$OMP END DO
!$OMP END PARALLEL

         ! Compute the energy injected by the jet in the current node
         en_inj_jj= 0.

         if (mpi_coords(2) == 0) then ! First node in y: jet injection region

            do kk = 1, nz
               do ii = 1, nx

                  if ((xzn(ii)*xzn(ii)+zzn(kk)*zzn(kk)) <= 1.0) then
                     en_inj_jj = en_inj_jj + &
                     ((1.+gama0(ii)/(gama0(ii)-1.)*pb/rhob)/sqrt(1.-velb*velb)-1.)*      &
                     rhob/sqrt(1.-velb*velb)*velb    &
                     *abs(xzn(ii+1)-xzn(ii))**2
                  endif
               enddo   
            enddo
      
         endif

         ! Gather all nodes energy injected by the jet into one array in the root node
         call MPI_Gather(en_inj_jj,1, MPI_DOUBLE_PRECISION,   &
                          en_inja,1, MPI_DOUBLE_PRECISION,   &
                          0, CART_WORLD, ierr)

         ! print*,'en_inj_jj',en_inj_jj
         ! print*,'en_inja',en_inja

         ! Create a
         if (cartrank == 0) then
            print*,'Energy injected by the jet in each node (en_inja)',en_inja

            en_inj(szi) = 0.
            
            do ii=1,nodes
               en_inj(szi) = en_inj(szi) + en_inja(ii)
            enddo
      
            !en_inj(szi) = en_inj(szi)*rho_0a*(c**2)*R_b**2*c
             
            print*,'Total energy injected at this time (en_inj)',en_inj(szi),'in szi', szi
            print*,''
            print*,'Node, shock position and pressure: '
         endif

         !--------------------------------------------------------- Compute the shock position

         ! MUSSOL VARIABLES DICTIONARY
         ! shposa := Shock position array for every x,z in the jet direction
         ! shposi := Shock position in the jet direction
         ! phia := Pressure at the shock position for every x,z in the jet direction
         ! phi := Pressure at the shock position
         ! shpostx := Shock position in the transversal x-direction for ervery y,z
         ! shpost := Shock position in the transversal x-direction
         ! jjp := Shock position x index
       
         dvol=(xzn(2)-xzn(1))*(yzn(2)-yzn(1))*(zzn(2)-zzn(1))

         xzn(nx+1) = xzn(nx) + (xzn(2)-xzn(1))
         yzn(ny+1) = yzn(ny) + (yzn(2)-yzn(1))
         zzn(nz+1) = zzn(nz) + (zzn(2)-zzn(1))

         ! print*, cartrank, xzn(1),xzn(nx), yzn(1), yzn(ny), zzn(1), zzn(nz)
         ! STOP

         shposi= 0. 
         shpostx = 0.
         phi = 0.
         jjp = 0

         if ((abs(physic(1,1,1)%vely) > 1.e-4 .or. abs(physic(nx,1,1)%vely) > 1.e-4 .or. & 
            abs(physic(1,1,nz)%vely) > 1.e-4 .or. abs(physic(nx/2,1,nz/2)%vely) > 1.e-4 &
            .or. abs(physic(nx,1,nz)%vely) > 1.e-4) &
            .and. ((abs(physic(1,ny,1)%vely) < 1.e-4 .and. abs(physic(nx,ny,1)%vely) < 1.e-4 .and. &
            abs(physic(1,ny,nz)%vely) < 1.e-4 .and. abs(physic(nx/2,ny,nz/2)%vely) < 1.e-4 &
            .and. abs(physic(nx,ny,nz)%vely) < 1.e-4 )) .or. mpi_coords(2) == mpi_dims(2) -1 ) then 

!$OMP PARALLEL DEFAULT(shared)&
!$OMP PRIVATE(ii,jj,kk,ll,mm,qq,vel,ratio)
!$OMP DO SCHEDULE(static)

            ! Shock position in the jet direction for every x,z
            do kk=1,nz
               do ii=1,nx
                  
                  ! End of the grid in the jet direction (minus 2)
                  jj=ny-2

                  shposa(ii,kk) = 0 !yzn(ny)
                  phia(ii,kk) = 0.

                  ! Searching for the shock
                  do while (jj > 2)

                     ! print*, abs(physic(ii,jj-7,kk)%pres-physic(ii,jj+7,kk)%pres)/physic(ii,jj+7,kk)%pres
                     
                     if (abs(physic(ii,jj-2,kk)%pres-physic(ii,jj+2,kk)%pres)/physic(ii,jj+2,kk)%pres>0.1 &
                        .and. physic(ii,jj,kk)%vely > 1.e-4) then
                       
                        shposa(ii,kk)=yzn(jj)

                        if (jj > 2) then
                           phia(ii,kk) =  physic(ii,jj-6,kk)%pres
                        else
                           phia(ii,kk) =  physic(ii,1,kk)%pres
                        endif

                        jj = 2

                     else
                        jj = jj - 1

                     endif

                  enddo
               enddo
            enddo

!$OMP END DO
!$OMP END PARALLEL

            ! Shock position in the jet directioon
            shposi=0.
            phi= phia(1,1)

            do kk=1, nz
               do ii=1,nx
                  if (shposa(ii,kk) > shposi) then
                     shposi = shposa(ii,kk)
                     phi = phia(ii,kk)
                     jjp = ii
                  endif
               enddo
            enddo

         endif

         ! Shock in the perpendicular x-direction
         if (mpi_coords(1) >= mpi_dims(1)/2 ) then
!$OMP PARALLEL DEFAULT(shared)&
!$OMP PRIVATE(ii,jj,kk,ratio)
!$OMP DO SCHEDULE(static)

            do kk=1,nz
               do jj=1,ny
                  ii=nx-2
                  shpost(jj,kk)=0.
                  do while (ii > 2)
                     if (abs(physic(ii-2,jj,kk)%pres-physic(ii+2,jj,kk)%pres)/physic(ii+2,jj,kk)%pres>0.1 &
                     .and. physic(ii,jj,kk)%vely > 1.e-4) then
                        shpost(jj,kk)=xzn(ii)
                        ii = 2
                     else
                        ii = ii - 1
                     endif
                  enddo
               enddo
            enddo

!$OMP END DO
!$OMP END PARALLEL

            ! Shock in the perpendicular x-direction
            shpostx=0.0
            do kk=1, nz
               do jj=1,ny
                  if (abs(shpost(jj,kk)) > shpostx) then
                     shpostx = abs(shpost(jj,kk))
                  endif
               enddo
            enddo

           endif

         if (mpi_coords(1) < mpi_dims(1)/2) then
!$OMP PARALLEL DEFAULT(shared)&
!$OMP PRIVATE(ii,jj,kk,ratio)
!$OMP DO SCHEDULE(static)
            do kk=1,nz
               do jj=1,ny
                  ii=4
                  shpost(jj,kk)=0.
                  do while (ii < nx-2)
                     if (abs(physic(ii+2,jj,kk)%pres-physic(ii-2,jj,kk)%pres)/physic(ii-2,jj,kk)%pres>0.1 &
                     .and. physic(ii,jj,kk)%vely > 1.e-4) then
                        shpost(jj,kk)=xzn(ii)
                        ii = nx - 2
                     else
                        ii = ii + 1
                     endif
                  enddo
               enddo
            enddo
!$OMP END DO
!$OMP END PARALLEL

            shpostx=0.0
            do kk=1, nz
               do jj=1,ny
                  if (abs(shpost(jj,kk)) > abs(shpostx)) then
                     shpostx = abs(shpost(jj,kk))
                  endif
               enddo
            enddo
         endif

         call MPI_BARRIER( MPI_COMM_WORLD, ierr )

         !------------------------------------------------------------------- COMPUTING MASSES AND ...

         ! MUSSOL VARIABLES DICTIONARY
         ! countp := Number of shocked cells
         ! contpco := Number of shocked cells in the cocoon
         ! countt := Number of total shocked cells
         ! counti := Number of schok cells in the x-sweep
         ! countj := Number of schok cells in the y-sweep
         ! countk := Number of schok cells in the z-sweep

         ! disp := Shocked cells
         ! dispco := Shocked cells in the cocoon

         countp=0. 
         countpco=0.
         countt=0. 
         xea = 1./1836.11

!$OMP PARALLEL DEFAULT(shared)&
!$OMP PRIVATE(ii,jj,kk)
!$OMP DO SCHEDULE(static)
         do kk=1,nz+1
            do jj=1,ny+1 
               do ii=1,nx+1 
                  disp(ii,jj,kk) = 0
 6                dispco(ii,jj,kk) = 0
               enddo
            enddo
         enddo  
!$OMP END DO
!$OMP END PARALLEL 

!$OMP PARALLEL DEFAULT(shared)&
!$OMP PRIVATE(ii,jj,kk,counti,countj,ir,xe,ze,zp,meff1,dpdrho,geb,gpb,dge,dgp)&
!$OMP PRIVATE(np,npa,ri,tema,rhoa0,epsa0,presa0,gama0,intarrayx,intarrayz)&
!$OMP REDUCTION(+:countp,countk)&
!$OMP REDUCTION(+:countpco)
!!!$OMP REDUCTION(+:count1,countt)

         countk = 0
         countp=0.
         countpco=0.

!$OMP DO SCHEDULE(static)
         do jj=1,ny+1

            countj = 0 ! Number of cells in the y-direction

            do kk=1,nz+1

               counti   = 0  ! Number of cells in x-direction

               do ii=1,nx+1

                  ! Ambient parameters
                  rhoa0(ii) = physica(ii,jj,kk)%densty !Code units
                  presa0(ii) = physica(ii,jj,kk)%pres !Code units
                  tema0(ii) = tema(ii,jj,kk) !Code units

                  ! tem(ii,jj,kk)=physica(ii,jj,kk)%pres*(c**2)*rho_0a/(xe/me_cgs+(1-xe)/mp_cgs)/ &
                  !       (kb*physica(ii,jj,kk)%densty*rho_0a) !Temperature in cgs
                  epsa0(ii) = physica(ii,jj,kk)%eps !Code units
                  gama0(ii) = gama(ii,jj,kk) !Code units

                  ! Evolved parameters in each cell
                  xe = physic(ii,jj,kk)%denstye/physic(ii,jj,kk)%densty
                  np = (xe/me_cgs+(1.0-xe)/mp_cgs)*(physic(ii,jj,kk)%densty*rho_0a) !cgs
                  npa = (xea/me_cgs+(1.0-xea)/mp_cgs)*(physica(ii,jj,kk)%densty*rho_0a) !cgs

                  ! Initialize x-direction array of variables
                  intarrayx(ii)%massa = 0.0
                  intarrayx(ii)%massa = 0.0 
                  intarrayx(ii)%massac = 0.0
                  intarrayx(ii)%massat = 0.0 
                  intarrayx(ii)%npti = 0.0
                  intarrayx(ii)%press_s = 0.0
                  intarrayx(ii)%rho_s = 0.0
                  intarrayx(ii)%tem_s = 0.0
                  intarrayx(ii)%vols = 0.0
                  intarrayx(ii)%press_co = 0.0
                  intarrayx(ii)%rho_co = 0.0
                  intarrayx(ii)%tem_co = 0.0
                  intarrayx(ii)%gamci = 0.0
                  intarrayx(ii)%epsci = 0.0
                  intarrayx(ii)%massac = 0.0
                  intarrayx(ii)%volco = 0.0 
                  intarrayx(ii)%entcoa = 0.0
                  intarrayx(ii)%massacoa = 0.0 
                  intarrayx(ii)%pdvco = 0.0 
                  intarrayx(ii)%entcoj = 0.0 
                  intarrayx(ii)%pdva0 = 0.0 
                  intarrayx(ii)%mass0 = 0.0 
                  intarrayx(ii)%entpj = 0.0
                  intarrayx(ii)%entpa = 0.0 
                  intarrayx(ii)%entpt = 0.0
                  intarrayx(ii)%epota = 0.0
                  intarrayx(ii)%eninta = 0.0
                  intarrayx(ii)%eninta0 = 0.0
                  intarrayx(ii)%enkina = 0.0 
                  intarrayx(ii)%enintj = 0.0 
                  intarrayx(ii)%enkinj = 0.0 
                  intarrayx(ii)%tauji = 0.0 
                  intarrayx(ii)%tauai = 0.0 
                  intarrayx(ii)%taua0i = 0.0
                  intarrayx(ii)%tauj_di = 0.0
                  intarrayx(ii)%taua_di = 0.0
                  intarrayx(ii)%taua0_di = 0.0
                  intarrayx(ii)%tauti = 0.0
                  intarrayx(ii)%lxt = 0.0 
                  intarrayx(ii)%pdva = 0.0 
                  intarrayx(ii)%mdva = 0.0
                  intarrayx(ii)%massj = physic(ii,jj,kk)%densty*rho_0a*physic(ii,jj,kk)%tracer*dvol

                  ! SHOCKED REGION (where the jet has already passed)
                  if (physic(ii,jj,kk)%pres > 1.1*presa0(ii)) then
                     intarrayx(ii)%npti = np*dvol

                     ! Shell region: x-contribution
                     if (physic(ii,jj,kk)%tracer .lt. 0.01) then

                        intarrayx(ii)%press_s = physic(ii,jj,kk)%pres*dvol
                        intarrayx(ii)%rho_s   = physic(ii,jj,kk)%densty*dvol
                        intarrayx(ii)%tem_s   = tem(ii,jj,kk)*dvol
                        intarrayx(ii)%vols   = dvol

                        intarrayx(ii)%volco   = 0.
                        intarrayx(ii)%press_co = 0.
                        intarrayx(ii)%rho_co   = 0.
                        intarrayx(ii)%tem_co   = 0.
                        intarrayx(ii)%gamci    = 0.
                        intarrayx(ii)%epsci    = 0.

                        intarrayx(ii)%massa  = physic(ii,jj,kk)%densty*rho_0a  &
                           *(1.-physic(ii,jj,kk)%tracer)*dvol
                        intarrayx(ii)%massac = 0.
                        intarrayx(ii)%massat = physic(ii,jj,kk)%densty*rho_0a*dvol

                        countp=countp+1.! Bumber of shocked cells

                     ! Jet cocoon: x-contribution
                     elseif ( physic(ii,jj,kk)%tracer >= 0.01) then

                        intarrayx(ii)%press_s = 0.
                        intarrayx(ii)%rho_s   = 0.
                        intarrayx(ii)%tem_s   = 0.
                        intarrayx(ii)%vols   = 0.

                        intarrayx(ii)%press_co = physic(ii,jj,kk)%pres*dvol
                        intarrayx(ii)%rho_co   = physic(ii,jj,kk)%densty*dvol
                        intarrayx(ii)%tem_co   = tem(ii,jj,kk)*dvol

                        ! if (cartrank==0) then
                        !    print*,'gama0 before:',gama0(ii)
                        !    print*,'DVOL before',dvol
                        ! endif

                        intarrayx(ii)%gamci    = gama0(ii)*dvol

                        ! if (cartrank==0) then
                        !    print*,'GAMCI=gama0*DVOL:',intarrayx(ii)%gamci
                        ! endif

                        intarrayx(ii)%epsci    = epsa0(ii)*dvol
                        intarrayx(ii)%volco   = dvol

                        intarrayx(ii)%massac  = physic(ii,jj,kk)%densty*rho_0a* & 
                                                (1.-physic(ii,jj,kk)%tracer)*dvol
                        intarrayx(ii)%massa = 0.
                        intarrayx(ii)%massat = physic(ii,jj,kk)%densty*rho_0a*dvol

                        countpco=countpco+1. ! Number of cells in the cocoon

                     endif

                    
                     if (physic(ii,jj,kk)%tracer .gt. 1.e-4) then

                        intarrayx(ii)%entcoa =  physic(ii,jj,kk)%densty*rho_0a*     &
                              physic(ii,jj,kk)%eps*                             &
                              (1.-physic(ii,jj,kk)%tracer)*                     &
                              dvol*(c**2) - rhoa0(ii)*rho_0a*epsa0(ii)*          &
                              dvol*(c**2) + 0.5*physic(ii,jj,kk)%densty*rho_0a*  &
                              (physic(ii,jj,kk)%vely**2+                        &
                              physic(ii,jj,kk)%velx**2+                        &
                              physic(ii,jj,kk)%velz**2)*(c**2)*                 &
                              (1.-physic(ii,jj,kk)%tracer)*dvol  

                        intarrayx(ii)%massacoa = physic(ii,jj,kk)%densty*rho_0a   &
                                          *(1.-physic(ii,jj,kk)%tracer)*dvol
                        intarrayx(ii)%npco = 2.*(1.-xe)*intarrayx(ii)%npti ! Leptonic jet: the number of ambient particles is twice (account for ambient electrons) the baryonic number
                        intarrayx(ii)%pdvco = physic(ii,jj,kk)%pres*dvol*rho_0a*(c**2)
                        
                        intarrayx(ii)%entpt = (tem(ii,jj,kk)/np**0.6667-          &
                           tema0(ii)/npa**0.6667)*dvol !-tema(ir)/npa^0.6667
                           ! tema0(ii)*m_0*c**2/kb/npa**0.6667*npa)*dvol !-tema(ir)/npa^0.6667

                        if (dispco(ii,jj,kk) .eq. 0) then
                           dispco(ii,jj,kk) = 1
                           intarrayx(ii)%pdva0 = physic(ii,jj,kk)%pres*dvol*rho_0a*(c**2)* &
                                 physic(ii,jj,kk)%tracer
                           intarrayx(ii)%entcoj =  physic(ii,jj,kk)%densty*rho_0a*        &
                              physic(ii,jj,kk)%eps*physic(ii,jj,kk)%tracer*dvol*(c**2) +   &
                                 0.5*physic(ii,jj,kk)%densty*rho_0a*                &
                                 (physic(ii,jj,kk)%vely**2+                         &
                                 physic(ii,jj,kk)%velx**2+                         &
                                 physic(ii,jj,kk)%velz)*(c**2)*                     &
                                 physic(ii,jj,kk)%tracer*dvol      
                           intarrayx(ii)%mass0  = rhoa0(ii)*rho_0a*dvol

                        else
                           intarrayx(ii)%entcoj = 0.
                           intarrayx(ii)%pdva0 = 0.
                           intarrayx(ii)%mass0  = 0.
                        endif   

                     else

                        intarrayx(ii)%entcoa = 0.
                        intarrayx(ii)%massacoa = 0.
                        intarrayx(ii)%npco = 0.
                        intarrayx(ii)%pdvco = 0.
                        intarrayx(ii)%entcoj = 0.
                        intarrayx(ii)%pdva0 = 0.
                        intarrayx(ii)%mass0  = 0. 

                     endif

                     ! Tracing particles from the JET
                  
                     !Entropy
                     intarrayx(ii)%entpj  = intarrayx(ii)%entpj  + tem(ii,jj,kk)/np**0.6667*physic(ii,jj,kk)%tracer*dvol
                     !Internal energy
                     intarrayx(ii)%enintj = physic(ii,jj,kk)%densty*rho_0a* & 
                                       physic(ii,jj,kk)%eps*                  &
                                       physic(ii,jj,kk)%tracer*dvol*(c**2)
                     !Kinetic energy       
                     intarrayx(ii)%enkinj = 0.5*physic(ii,jj,kk)%densty*rho_0a*   &
                     (physic(ii,jj,kk)%vely**2+                              &
                     physic(ii,jj,kk)%velx**2+                              &
                     physic(ii,jj,kk)%velz**2)                              &
                     *physic(ii,jj,kk)%tracer*dvol*(c**2)         

                         
                     ! Tracing particles from the AMBIENT
                     !Entropy
                     intarrayx(ii)%entpa = intarrayx(ii)%entpa + tem(ii,jj,kk)/np**0.6667*    &
                     (1.-physic(ii,jj,kk)%tracer)*dvol !Entropy
                     !Internal energy
                     intarrayx(ii)%eninta0 = rhoa0(ii)*rho_0a*epsa0(ii)*dvol*(c**2)  
                     intarrayx(ii)%eninta = physic(ii,jj,kk)%densty*rho_0a*        &
                           physic(ii,jj,kk)%eps*                             &
                           (1.-physic(ii,jj,kk)%tracer)*                     &
                           dvol*(c**2) - intarrayx(ii)%eninta0
                     !Potential energy
                     intarrayx(ii)%epota = 0.0   
                     !Kinetic energy
                     intarrayx(ii)%enkina = 0.5*physic(ii,jj,kk)%densty*rho_0a*    &
                           (physic(ii,jj,kk)%vely**2+                        &
                           physic(ii,jj,kk)%velx**2+                        &
                           physic(ii,jj,kk)%velz**2)*(c**2)*                 &
                           (1.-physic(ii,jj,kk)%tracer)*dvol

                     ! Stress-tensor components
                     intarrayx(ii)%tauji = (physic(ii,jj,kk)%densty*(lof(ii,jj,kk)**2)*  &
                           hr(ii,jj,kk)-physic(ii,jj,kk)%pres)*                  &
                           dvol*physic(ii,jj,kk)%tracer*rho_0a*(c**2)             

                     intarrayx(ii)%tauai = (physic(ii,jj,kk)%densty*(lof(ii,jj,kk)**2)  &
                           *hr(ii,jj,kk)-physic(ii,jj,kk)%pres)*dvol *           &
                           (1.-physic(ii,jj,kk)%tracer)*rho_0a*(c**2) -           &
                           rhoa0(ii)*(1.+epsa0(ii))*rho_0a*dvol*(c**2)

                     intarrayx(ii)%taua0i = rhoa0(ii)*rho_0a*(1.+epsa0(ii))*(c**2)*dvol

                     intarrayx(ii)%tauj_di = (physic(ii,jj,kk)%densty*(lof(ii,jj,kk)**2)* &
                           hr(ii,jj,kk)-physic(ii,jj,kk)%pres)*                    &
                           dvol*physic(ii,jj,kk)%tracer*rho_0a*(c**2) -             &
                           physic(ii,jj,kk)%densty*lof(ii,jj,kk)*(c**2)*            &
                           physic(ii,jj,kk)%tracer*dvol*rho_0a 

                     intarrayx(ii)%taua_di = (physic(ii,jj,kk)%densty*lof(ii,jj,kk)**2* &
                           hr(ii,jj,kk)-physic(ii,jj,kk)%pres)*dvol*              &
                           (1.-physic(ii,jj,kk)%tracer)*rho_0a*(c**2) -            &
                           physic(ii,jj,kk)%densty*lof(ii,jj,kk)*(c**2)*           &
                           (1.-physic(ii,jj,kk)%tracer)*dvol*rho_0a -             &
                           rhoa0(ii)*rho_0a*epsa0(ii)*(c**2)*dvol

                     intarrayx(ii)%taua0_di = rhoa0(ii)*rho_0a*epsa0(ii)*(c**2)*dvol

                     intarrayx(ii)%tauti = (physic(ii,jj,kk)%densty*(lof(ii,jj,kk)**2)*    &
                           hr(ii,jj,kk)-physic(ii,jj,kk)%pres)*dvol*                        &
                           rho_0a*(c**2) - rhoa0(ii)*rho_0a*(1.+epsa0(ii))*(c**2)*dvol

                     ! Counting cells in the x-direction
                     counti = counti + 1 

                     ! Radiated luminosity (Bremsstrahlung)
                     intarrayx(ii)%lxt = np**2*KB1*sqrt(tem(ii,jj,kk))*  &
                        (1.+KB2*tem(ii,jj,kk))*dvol

                     ! Pressure-volume and mass-volume works
                     if (disp(ii,jj,kk) .eq. 0) then
                        disp(ii,jj,kk) = 1
                        intarrayx(ii)%pdva = physic(ii,jj,kk)%pres*dvol*rho_0a*(c**2)
                        intarrayx(ii)%mdva = rhoa0(ii)*rho_0a*dvol
                     else
                        intarrayx(ii)%pdva = 0.
                        intarrayx(ii)%mdva = 0.
                     endif

                  endif
               enddo

               ! Initialize the quantities over the z-direction
               intarrayz(kk)%massj = 0.0
               intarrayz(kk)%massa = 0.0
               intarrayz(kk)%massat = 0.0
               intarrayz(kk)%npti = 0.0
               intarrayz(kk)%press_s = 0.0
               intarrayz(kk)%rho_s = 0.0
               intarrayz(kk)%tem_s = 0.0
               intarrayz(kk)%press_co = 0.0
               intarrayz(kk)%rho_co = 0.0
               intarrayz(kk)%tem_co = 0.0
               intarrayz(kk)%gamci = 0.0
               intarrayz(kk)%epsci = 0.0
               intarrayz(kk)%vols = 0.0
               intarrayz(kk)%massac = 0.0
               intarrayz(kk)%volco = 0.0
               intarrayz(kk)%entcoa = 0.0
               intarrayz(kk)%massacoa = 0.0
               intarrayz(kk)%npco = 0.0
               intarrayz(kk)%pdvco = 0.0
               intarrayz(kk)%entcoj = 0.0
               intarrayz(kk)%pdva0 = 0.0
               intarrayz(kk)%mass0 = 0.0
               intarrayz(kk)%entpj = 0.0
               intarrayz(kk)%entpa = 0.0
               intarrayz(kk)%entpt = 0.0
               intarrayz(kk)%epota = 0.0
               intarrayz(kk)%eninta = 0.0
               intarrayz(kk)%eninta0 = 0.0
               intarrayz(kk)%enkina = 0.0
               intarrayz(kk)%enintj = 0.0
               intarrayz(kk)%enkinj = 0.0
               intarrayz(kk)%tauji = 0.0
               intarrayz(kk)%tauai = 0.0
               intarrayz(kk)%taua0i = 0.0
               intarrayz(kk)%tauj_di = 0.0
               intarrayz(kk)%taua_di = 0.0
               intarrayz(kk)%taua0_di = 0.0
               intarrayz(kk)%tauti = 0.0
               intarrayz(kk)%lxt = 0.0
               intarrayz(kk)%pdva = 0.0
               intarrayz(kk)%mdva = 0.0

               ! Integrate the quantities over the x-direction
               if (counti > 0) then
                  countj=countj + 1 ! Counting cells in the y-direction
                  call INTEGRAR(nx,nz,kk,nvar,erro,h1,hmin,nok,nbad, &
                              xzn, intarrayx, intarrayz)  
               endif      
            enddo

            ! Initialize the quantities over the y-direction
            intarrayy(jj)%massj = 0.0
            intarrayy(jj)%massa = 0.0
            intarrayy(jj)%massat = 0.0
            intarrayy(jj)%npti = 0.0
            intarrayy(jj)%press_s = 0.0
            intarrayy(jj)%rho_s = 0.0
            intarrayy(jj)%tem_s = 0.0
            intarrayy(jj)%press_co = 0.0
            intarrayy(jj)%rho_co = 0.0
            intarrayy(jj)%tem_co = 0.0
            intarrayy(jj)%gamci = 0.0
            intarrayy(jj)%epsci = 0.0
            intarrayy(jj)%vols = 0.0
            intarrayy(jj)%massac = 0.0
            intarrayy(jj)%volco = 0.0
            intarrayy(jj)%entcoa = 0.0
            intarrayy(jj)%massacoa = 0.0
            intarrayy(jj)%npco = 0.0
            intarrayy(jj)%pdvco = 0.0
            intarrayy(jj)%entcoj = 0.0
            intarrayy(jj)%pdva0 = 0.0
            intarrayy(jj)%mass0 = 0.0
            intarrayy(jj)%entpj = 0.0
            intarrayy(jj)%entpa = 0.0
            intarrayy(jj)%entpt = 0.0
            intarrayy(jj)%epota = 0.0
            intarrayy(jj)%eninta = 0.0
            intarrayy(jj)%eninta0 = 0.0
            intarrayy(jj)%enkina = 0.0
            intarrayy(jj)%enintj = 0.0
            intarrayy(jj)%enkinj = 0.0
            intarrayy(jj)%tauji = 0.0
            intarrayy(jj)%tauai = 0.0
            intarrayy(jj)%taua0i = 0.0
            intarrayy(jj)%tauj_di = 0.0
            intarrayy(jj)%taua_di = 0.0
            intarrayy(jj)%taua0_di = 0.0
            intarrayy(jj)%tauti = 0.0
            intarrayy(jj)%lxt = 0.0
            intarrayy(jj)%pdva = 0.0
            intarrayy(jj)%mdva = 0.0

            ! Integrate the quantities over the y-direction
            if (countj > 0) then
               countk = countk +1 ! Counting cells in the z-direction
               call INTEGRAR(nz,ny,jj,nvar,erro,h1,hmin,nok,nbad, &
                              zzn, intarrayz, intarrayy)            
            endif    
         enddo
!$OMP END DO
!$OMP END PARALLEL 

         ! Initialize the TOTAL quantities for the current node
         arrayt(1)%massj = 0.0
         arrayt(1)%massa = 0.0
         arrayt(1)%massat = 0.0
         arrayt(1)%npti = 0.0
         arrayt(1)%press_s = 0.0
         arrayt(1)%rho_s = 0.0
         arrayt(1)%tem_s = 0.0
         arrayt(1)%press_co = 0.0
         arrayt(1)%rho_co = 0.0
         arrayt(1)%tem_co = 0.0
         arrayt(1)%gamci = 0.0
         arrayt(1)%epsci = 0.0
         arrayt(1)%vols = 0.0
         arrayt(1)%massac = 0.0
         arrayt(1)%volco = 0.0
         arrayt(1)%entcoa = 0.0
         arrayt(1)%massacoa = 0.0
         arrayt(1)%npco = 0.0
         arrayt(1)%pdvco = 0.0
         arrayt(1)%entcoj = 0.0
         arrayt(1)%pdva0 = 0.0
         arrayt(1)%mass0 = 0.0
         arrayt(1)%entpj = 0.0
         arrayt(1)%entpa = 0.0
         arrayt(1)%entpt = 0.0
         arrayt(1)%epota = 0.0
         arrayt(1)%eninta = 0.0
         arrayt(1)%eninta0 = 0.0
         arrayt(1)%enkina = 0.0
         arrayt(1)%enintj = 0.0
         arrayt(1)%enkinj = 0.0
         arrayt(1)%tauji = 0.0
         arrayt(1)%tauai = 0.0
         arrayt(1)%taua0i = 0.0
         arrayt(1)%tauj_di = 0.0
         arrayt(1)%taua_di = 0.0
         arrayt(1)%taua0_di = 0.0
         arrayt(1)%tauti = 0.0
         arrayt(1)%lxt = 0.0
         arrayt(1)%pdva = 0.0
         arrayt(1)%mdva = 0.0
         
         ! Integrate the quantities over the z-direction
         if (countk > 0) then
            call INTEGRAR3(ny,1,1,nvar,erro,h1,hmin,nok,nbad, &
                           yzn, intarrayy, arrayt) 
         endif

         call MPI_Gather( arrayt,nv, MPI_DOUBLE_PRECISION,   &
                        arrayg,nv, MPI_DOUBLE_PRECISION,   &
                        0, CART_WORLD, ierr)
         call MPI_Gather(shposi,1, MPI_DOUBLE_PRECISION,       &
                        shposg,1, MPI_DOUBLE_PRECISION,   &
                        0, CART_WORLD, ierr)
         call MPI_Gather(shpostx,1, MPI_DOUBLE_PRECISION,       &
                        shposgt,1, MPI_DOUBLE_PRECISION,   &
                        0, CART_WORLD, ierr)
         call MPI_Gather(phi,1, MPI_DOUBLE_PRECISION,   &
                        phig,1, MPI_DOUBLE_PRECISION,   &
                        0, CART_WORLD, ierr)

         ! Initialize the TOTAL quantities per time array for the grid in the current snapshot
         if (cartrank== 0) then 
            arrayw(szi)%massj = 0.0
            arrayw(szi)%massa = 0.0
            arrayw(szi)%massat = 0.0
            arrayw(szi)%npti = 0.0
            arrayw(szi)%press_s = 0.0
            arrayw(szi)%rho_s = 0.0
            arrayw(szi)%tem_s = 0.0
            arrayw(szi)%press_co = 0.0
            arrayw(szi)%rho_co = 0.0
            arrayw(szi)%tem_co = 0.0
            arrayw(szi)%gamci = 0.0
            arrayw(szi)%epsci = 0.0
            arrayw(szi)%vols = 0.0
            arrayw(szi)%massac = 0.0
            arrayw(szi)%volco = 0.0
            arrayw(szi)%entcoa = 0.0
            arrayw(szi)%massacoa = 0.0
            arrayw(szi)%npco = 0.0
            arrayw(szi)%pdvco = 0.0
            arrayw(szi)%entcoj = 0.0
            arrayw(szi)%pdva0 = 0.0
            arrayw(szi)%mass0 = 0.0
            arrayw(szi)%entpj = 0.0
            arrayw(szi)%entpa = 0.0
            arrayw(szi)%entpt = 0.0
            arrayw(szi)%epota = 0.0
            arrayw(szi)%eninta = 0.0
            arrayw(szi)%eninta0 = 0.0
            arrayw(szi)%enkina = 0.0
            arrayw(szi)%enintj = 0.0
            arrayw(szi)%enkinj = 0.0
            arrayw(szi)%tauji = 0.0
            arrayw(szi)%tauai = 0.0
            arrayw(szi)%taua0i = 0.0
            arrayw(szi)%tauj_di = 0.0
            arrayw(szi)%taua_di = 0.0
            arrayw(szi)%taua0_di = 0.0
            arrayw(szi)%tauti = 0.0
            arrayw(szi)%lxt = 0.0
            arrayw(szi)%pdva = 0.0
            arrayw(szi)%mdva = 0.0

            shpos(szi) = shposg(1)
            arrayw(szi)%hpos = shposg(1) 
            arrayw(szi)%tpos = shposgt(1)
            ph(szi) = phig(1)

            ! Add all the nodes contributions to the total quantities
            do jj = 1, nodes

               if (jj==1) print*,'-----------------------------------'
               if (jj==1) print*,'Node, Shock positions and pressures'

               print*,jj,shposg(jj),shposgt(jj),phig(jj)

               if (shposgt(jj) > arrayw(szi)%tpos) then
                  arrayw(szi)%tpos = shposgt(jj)
               endif

               if (szi == 1) then
                  if (phig(jj) > ph(szi)) then
                     ph(szi) = phig(jj)
                     shpos(szi) = shposg(jj)
                  endif
               else
                  if (phig(jj) > ph(szi) .and. shposg(jj) > shpos(szi) &
                       .and. shposg(jj) > shpos(szi-1)) then
                     ph(szi) = phig(jj)
                     shpos(szi) = shposg(jj)
                  endif
               endif

               ! Computation of the total quantities
               arrayw(szi)%massj = arrayw(szi)%massj+arrayg(jj)%massj
               arrayw(szi)%massa = arrayw(szi)%massa+arrayg(jj)%massa
               arrayw(szi)%massat = arrayw(szi)%massat+arrayg(jj)%massat
               arrayw(szi)%npti = arrayw(szi)%npti+arrayg(jj)%npti
               arrayw(szi)%press_s = arrayw(szi)%press_s+arrayg(jj)%press_s
               arrayw(szi)%rho_s = arrayw(szi)%rho_s+arrayg(jj)%rho_s
               arrayw(szi)%tem_s =  arrayw(szi)%tem_s+arrayg(jj)%tem_s
               arrayw(szi)%press_co = arrayw(szi)%press_co+arrayg(jj)%press_co
               arrayw(szi)%rho_co =  arrayw(szi)%rho_co+arrayg(jj)%rho_co
               arrayw(szi)%tem_co =  arrayw(szi)%tem_co+arrayg(jj)%tem_co
               arrayw(szi)%gamci =  arrayw(szi)%gamci+arrayg(jj)%gamci
               arrayw(szi)%epsci = arrayw(szi)%epsci+arrayg(jj)%epsci
               arrayw(szi)%vols =  arrayw(szi)%vols+arrayg(jj)%vols
               arrayw(szi)%massac = arrayw(szi)%massac+arrayg(jj)%massac
               arrayw(szi)%volco = arrayw(szi)%volco+arrayg(jj)%volco
               arrayw(szi)%entcoa = arrayw(szi)%entcoa+arrayg(jj)%entcoa
               arrayw(szi)%massacoa = arrayw(szi)%massacoa+arrayg(jj)%massacoa
               arrayw(szi)%npco = arrayw(szi)%npco+arrayg(jj)%npco
               arrayw(szi)%pdvco = arrayw(szi)%pdvco+arrayg(jj)%pdvco
               arrayw(szi)%entcoj = arrayw(szi)%entcoj+arrayg(jj)%entcoj
               arrayw(szi)%pdva0 = arrayw(szi)%pdva0+arrayg(jj)%pdva0
               arrayw(szi)%mass0 = arrayw(szi)%mass0+arrayg(jj)%mass0
               arrayw(szi)%entpj = arrayw(szi)%entpj+arrayg(jj)%entpj
               arrayw(szi)%entpa = arrayw(szi)%entpa+arrayg(jj)%entpa
               arrayw(szi)%entpt = arrayw(szi)%entpt+arrayg(jj)%entpt
               arrayw(szi)%epota = arrayw(szi)%epota+arrayg(jj)%epota
               arrayw(szi)%eninta = arrayw(szi)%eninta+arrayg(jj)%eninta
               arrayw(szi)%eninta0 = arrayw(szi)%eninta0+arrayg(jj)%eninta0
               arrayw(szi)%enkina = arrayw(szi)%enkina+arrayg(jj)%enkina
               arrayw(szi)%enintj = arrayw(szi)%enintj+arrayg(jj)%enintj
               arrayw(szi)%enkinj = arrayw(szi)%enkinj+arrayg(jj)%enkinj
               arrayw(szi)%tauji = arrayw(szi)%tauji+arrayg(jj)%tauji
               arrayw(szi)%tauai = arrayw(szi)%tauai+arrayg(jj)%tauai
               arrayw(szi)%taua0i = arrayw(szi)%taua0i+arrayg(jj)%taua0i
               arrayw(szi)%tauj_di = arrayw(szi)%tauj_di+arrayg(jj)%tauj_di
               arrayw(szi)%taua_di = arrayw(szi)%taua_di+arrayg(jj)%taua_di
               arrayw(szi)%taua0_di = arrayw(szi)%taua0_di+arrayg(jj)%taua0_di
               arrayw(szi)%tauti = arrayw(szi)%tauti+arrayg(jj)%tauti
               arrayw(szi)%lxt = arrayw(szi)%lxt+arrayg(jj)%lxt
               arrayw(szi)%pdva = arrayw(szi)%pdva+arrayg(jj)%pdva
               arrayw(szi)%mdva = arrayw(szi)%mdva+arrayg(jj)%mdva
               if (szi > 1) then
                  arrayw(szi)%eninj = en_inj(szi)*(timej*(R_b/c)-arrayw(szi-1)%timep)
               else
                  arrayw(szi)%eninj = en_inj(szi)*(timej*(R_b/c))
               endif
            enddo

            arrayw(szi)%press_s   = arrayw(szi)%press_s/arrayw(szi)%vols                        
            arrayw(szi)%rho_s   = arrayw(szi)%rho_s/arrayw(szi)%vols                        
            arrayw(szi)%tem_s   = arrayw(szi)%tem_s/arrayw(szi)%vols 
            arrayw(szi)%press_co = arrayw(szi)%press_co/arrayw(szi)%volco
            arrayw(szi)%rho_co   = arrayw(szi)%rho_co/arrayw(szi)%volco
            arrayw(szi)%tem_co   = arrayw(szi)%tem_co/arrayw(szi)%volco
            arrayw(szi)%gamci    = arrayw(szi)%gamci/arrayw(szi)%volco
            arrayw(szi)%epsci    = arrayw(szi)%epsci/arrayw(szi)%volco

            mass_ent(szi)  = arrayw(szi)%massa + arrayw(szi)%massac

           ! Convert the quantities to cgs units
            arrayw(szi)%vol = arrayw(szi)%vols+arrayw(szi)%volco
            arrayw(szi)%entpj = arrayw(szi)%entpj/arrayw(szi)%vol
            arrayw(szi)%entpa = arrayw(szi)%entpa/arrayw(szi)%vol
            arrayw(szi)%massj = arrayw(szi)%massj*R_b**3
            arrayw(szi)%massa = arrayw(szi)%massa*R_b**3
            arrayw(szi)%massat = arrayw(szi)%massat*R_b**3
            arrayw(szi)%npti = arrayw(szi)%npti*R_b**3
            arrayw(szi)%press_s = arrayw(szi)%press_s*(c**2)*rho_0a
            arrayw(szi)%rho_s = arrayw(szi)%rho_s*rho_0a
            arrayw(szi)%press_co = arrayw(szi)%press_co*(c**2)*rho_0a
            arrayw(szi)%rho_co =  arrayw(szi)%rho_co*rho_0a
            arrayw(szi)%epsci = arrayw(szi)%epsci*(c**2)
            arrayw(szi)%vols =  arrayw(szi)%vols*R_b**3
            arrayw(szi)%massac = arrayw(szi)%massac*R_b**3
            arrayw(szi)%volco = arrayw(szi)%volco*R_b**3
            arrayw(szi)%entcoa = arrayw(szi)%entcoa*R_b**3
            arrayw(szi)%massacoa = arrayw(szi)%massacoa*R_b**3
            arrayw(szi)%npco = arrayw(szi)%npco*R_b**3
            arrayw(szi)%pdvco = arrayw(szi)%pdvco*R_b**3
            arrayw(szi)%entcoj = arrayw(szi)%entcoj*R_b**3
            arrayw(szi)%pdva0 = arrayw(szi)%pdva0*R_b**3
            arrayw(szi)%mass0 = arrayw(szi)%mass0*R_b**3
            arrayw(szi)%entpt = arrayw(szi)%entpt*R_b**3
            arrayw(szi)%epota = arrayw(szi)%epota*R_b**3
            arrayw(szi)%eninta = arrayw(szi)%eninta*R_b**3
            arrayw(szi)%eninta0 = arrayw(szi)%eninta0*R_b**3
            arrayw(szi)%enkina = arrayw(szi)%enkina*R_b**3
            arrayw(szi)%enintj = arrayw(szi)%enintj*R_b**3
            arrayw(szi)%enkinj = arrayw(szi)%enkinj*R_b**3
            arrayw(szi)%tauji = arrayw(szi)%tauji*R_b**3
            arrayw(szi)%tauai = arrayw(szi)%tauai*R_b**3
            arrayw(szi)%taua0i = arrayw(szi)%taua0i*R_b**3
            arrayw(szi)%tauj_di = arrayw(szi)%tauj_di*R_b**3
            arrayw(szi)%taua_di = arrayw(szi)%taua_di*R_b**3
            arrayw(szi)%taua0_di = arrayw(szi)%taua0_di*R_b**3
            arrayw(szi)%tauti = arrayw(szi)%tauti*R_b**3
            arrayw(szi)%lxt = arrayw(szi)%lxt*R_b**3
            arrayw(szi)%pdva = arrayw(szi)%pdva*R_b**3
            arrayw(szi)%mdva = arrayw(szi)%mdva*rho_0a*R_b**3
            arrayw(szi)%eninj = arrayw(szi)%eninj*rho_0a*(c**2)*R_b**2*c
                    
            if (szi .gt. 1) then
               arrayw(szi)%pdva  = arrayw(szi-1)%pdva + arrayw(szi)%pdva
               arrayw(szi)%mdva = arrayw(szi-1)%mdva + arrayw(szi)%mdva
               arrayw(szi)%pdva0  = arrayw(szi-1)%pdva0 + arrayw(szi)%pdva0
               arrayw(szi)%mass0  = arrayw(szi-1)%mass0 + arrayw(szi)%mass0
               arrayw(szi)%entcoj  = arrayw(szi-1)%entcoj + arrayw(szi)%entcoj
            endif
                           
            arrayw(szi)%vol = arrayw(szi)%vols+arrayw(szi)%volco
            arrayw(szi)%timep = timej*R_b/c
            arrayw(szi)%hpos = shpos(szi)
            arrayw(szi)%phe = ph(szi)*(c**2)*rho_0a

            if (szi > 1) then
               arrayw(szi)%vh=(arrayw(szi)%hpos*R_b-arrayw(szi-1)%hpos*R_b)/  & 
                              (arrayw(szi)%timep-arrayw(szi-1)%timep)/c
            else
               arrayw(szi)%vh = arrayw(szi)%hpos*R_b/arrayw(szi)%timep/c
            endif

            arrayw(szi)%machh=arrayw(szi)%vh/csa

            print*,''
            print*,'R_b:',R_b,R_b/pc
            print*,'------------------------------ JET PARAMETERS ---------------------------------'
            print*,'Time [Myr] and h-t positions [kpc] of the shock front: ',arrayw(szi)%timep/(365*24*3600*1e6),arrayw(szi)%hpos*R_b/pc/1e3,arrayw(szi)%tpos*R_b/pc/1e3
            print*,'Shock head velocity [c] and Mach number: ',arrayw(szi)%vh,arrayw(szi)%machh
            print*,'Shock head pressure [cgs] value: ',arrayw(szi)%phe 
            print*,'Jet total mass: ',arrayw(szi)%massj
            print*,'Jet injected energy: ',arrayw(szi)%eninj
            print*,''
            print*,'----------------------------- Jet region --------------------------------------'
            print*,'------------------------- (pres >= 1.1*pres_0) ----------------------------------'
            print*,'Internal and kinetic energy due to jet particles: ',arrayw(szi)%enintj,arrayw(szi)%enkinj
            print*,'Internal and kinetic energy due to ambient particles: ',arrayw(szi)%eninta,arrayw(szi)%enkina
            print*,'Entropy due to jet particles: ',arrayw(szi)%entpj
            print*,'Pressure-volume work and mass-volume: ',arrayw(szi)%pdva,arrayw(szi)%mdva
            print*,'Luminosity: ',arrayw(szi)%lxt
            print*,'Entropy due to ambient particles: ',arrayw(szi)%entpa
            print*,'Stress-tensor components: ',arrayw(szi)%tauji,arrayw(szi)%tauai,arrayw(szi)%taua0i
            print*,'Stress-tensor components: ',arrayw(szi)%tauj_di,arrayw(szi)%taua_di,arrayw(szi)%taua0_di
            print*,'Stress-tensor components: ',arrayw(szi)%tauti
            print*,'Volume (cocoon+shell): ',arrayw(szi)%vol
            print*,''
            print*,'-------------------------------- Cocoon ---------------------------------------'
            print*,'---------------------------- (tracer >= 0.01) ---------------------------------'
            print*,'Pressure, density and temperature: ',arrayw(szi)%press_co,arrayw(szi)%rho_co,arrayw(szi)%tem_co
            print*,'Initial specific internal energy and adiabatic index: ',arrayw(szi)%epsci,arrayw(szi)%gamci
            print*,'Mass acretted from the ambient and total: ',arrayw(szi)%massac,arrayw(szi)%massac
            print*,'--------------------------- (tracer >= 1.e-4) ---------------------------------'
            print*,'Total energies for ambient particles and jet particles: ',arrayw(szi)%entcoa,arrayw(szi)%entcoj
            print*,'Pressure-volume work with and without tracer: ',arrayw(szi)%pdvco,arrayw(szi)%pdva0
            print*,'Number of particles: ',arrayw(szi)%npco
            print*,'Final and initial mass: ',arrayw(szi)%massacoa,arrayw(szi)%mass0
            print*,'Volume: ',arrayw(szi)%volco
            print*,'Cell count: ',countpco
            print*,'----------------------------- Shell/shocked -----------------------------------'
            print*,'---------------------------- (tracer < 0.01) ----------------------------------'
            print*,'Pressure, density y temperature: ',arrayw(szi)%press_s,arrayw(szi)%rho_s,arrayw(szi)%tem_s
            print*,'Internal and kinectic energy: ', arrayw(szi)%eninta,arrayw(szi)%enkina
            print*,'Entropy: ',arrayw(szi)%entpt
            print*,'Mass acretted from the ambient: ',arrayw(szi)%massa,arrayw(szi)%massat
            print*,'Volume: ',arrayw(szi)%vols
            print*,'Cell count: ',countp
            print*,'================================================================================'
            print*,''

            ! Write analysis results in file
            if (sziw >= 2) then
               print*,''
               print*,'WRITING RESULTS IN FILE ', TRIM(path_output)//'/'//'results_'//basenm
               print*,''
               open(40, file=TRIM(path_output)//'/'//'results_'//basenm,form='unformatted') 
               write(40) sz     !,ny0,massaof,enintaof,entpaof
               write(40) (arrayw(jj)%timep,arrayw(jj)%vh,arrayw(jj)%phe,        &
                          arrayw(jj)%machh,arrayw(jj)%hpos,arrayw(jj)%tpos,     &
                          arrayw(jj)%press_s,arrayw(jj)%rho_s,arrayw(jj)%tem_s, &
                          arrayw(jj)%press_co,arrayw(jj)%rho_co,                &
                          arrayw(jj)%tem_co,arrayw(jj)%epsci,                   &
                          arrayw(jj)%gamci,                                     &
                          arrayw(jj)%massa,arrayw(jj)%massac,arrayw(jj)%massj,  & 
                          arrayw(jj)%massat,arrayw(jj)%entpj,arrayw(jj)%entpt,   &
                          arrayw(jj)%entpa,arrayw(jj)%eninta,arrayw(jj)%eninta0,&
                          arrayw(jj)%enkina,arrayw(jj)%epota,                   &
                          arrayw(jj)%npti,arrayw(jj)%enintj,                    &
                          arrayw(jj)%enkinj,arrayw(jj)%pdva,arrayw(jj)%mdva,    &
                          arrayw(jj)%pdva0,arrayw(jj)%mass0,                   &
                          arrayw(jj)%tauji,arrayw(jj)%tauai,arrayw(jj)%tauj_di, &
                          arrayw(jj)%taua_di,arrayw(jj)%lxt,                    &
                          arrayw(jj)%tauti,arrayw(jj)%vols,arrayw(jj)%volco,  &
                          arrayw(jj)%entcoa,arrayw(jj)%massacoa,              &
                          arrayw(jj)%pdvco,arrayw(jj)%entcoj,arrayw(jj)%npco, &
                          arrayw(jj)%vol,arrayw(jj)%eninj,jj=1,szi)
               write(40) (yzn(ii), ii=1,ny0)
               close(40)
               sziw = 0
            endif
         endif

         ! sziw = sziw + sz
         ! countp=0.
         ! countpco=0.
         ! count_frames = count_frames + sz
         ! number = number + sz
         ! rst_file = sz

         sziw = sziw + 1
         countp=0.
         countpco=0.
         count_frames = count_frames + 1
         number = number + 1
         rst_file = r_filer

         if (szi==0) then
            sziw = sziw
            countp=0.
            countpco=0.
            count_frames = count_frames
            number = number
            rst_file = r_filer
         endif

    ENDDO

      ! Write analysis results in file
      if (cartrank == 0) then
         print*,''
         print*,'WRITING RESULTS IN FILE ', TRIM(path_output)//'/'//'results_'//basenm//'_0'
         print*,''
         open(40, file=TRIM(path_output)//'/'//'results_'//basenm//'_0',form='unformatted') 
         write(40) sz           !,ny0,massaof,enintaof,entpaof
         write(40) (arrayw(jj)%timep,arrayw(jj)%vh, arrayw(jj)%phe,       &
                    arrayw(jj)%machh,arrayw(jj)%hpos,arrayw(jj)%tpos,     &
                    arrayw(jj)%press_s,arrayw(jj)%rho_s,arrayw(jj)%tem_s, &
                    arrayw(jj)%press_co,arrayw(jj)%rho_co,                &
                    arrayw(jj)%tem_co,arrayw(jj)%epsci,                   &
                    arrayw(jj)%gamci,                                     &
                    arrayw(jj)%massa,arrayw(jj)%massac,arrayw(jj)%massj,  & 
                    arrayw(jj)%massat,arrayw(jj)%entpj,arrayw(jj)%entpt,   &
                    arrayw(jj)%entpa,arrayw(jj)%eninta,arrayw(jj)%eninta0,&
                    arrayw(jj)%enkina,arrayw(jj)%epota,                   &
                    arrayw(jj)%npti,arrayw(jj)%enintj,                    &
                    arrayw(jj)%enkinj,arrayw(jj)%pdva,arrayw(jj)%mdva,    &
                    arrayw(jj)%pdva0,arrayw(jj)%mass0,                   &
                    arrayw(jj)%tauji,arrayw(jj)%tauai,arrayw(jj)%tauj_di, &
                    arrayw(jj)%taua_di,arrayw(jj)%lxt,                    &
                    arrayw(jj)%tauti,arrayw(jj)%vols,arrayw(jj)%volco,  &
                    arrayw(jj)%entcoa,arrayw(jj)%massacoa,              &
                    arrayw(jj)%pdvco,arrayw(jj)%entcoj,arrayw(jj)%npco, &
                    arrayw(jj)%vol,arrayw(jj)%eninj, jj=1,sz)
         close(40)
      endif

      ! print*, 'Data saved in files ', 'results'//basenm

      deallocate( xznl, xzn, xznr,        &
                     yznl, yzn, yznr,        &
                     zznl, zzn, zznr,        &
                     grav, rhoa,             &
                     pa, dpady, intarrayx,   &
                     intarrayz, intarrayy, arrayt,    &
                     arrayg )
      deallocate( disp, dispco, kk2 )
      deallocate(tem, tema, gam, gama, hr, lof, phs, rhoa0,  &
               presa0, epsa0, gama0, tema0 )
      deallocate( physic, physica )
      deallocate( arrayw )
      deallocate( shpos,shpost,ph,shposg,shposgt, phig )
      deallocate(mass_ent) 

      call par_end( )

      END PROGRAM

!===============================================================================
!     NAME: ERROR
!     AUTHOR: Manel Perucho
!===============================================================================

      subroutine ERROR( routine, message, fich, line )
      implicit none
# include "types.h"

!------------------------------------------Input Variables

      character(*) :: routine
      character(*) :: message
      character(*) :: fich
      integer(is)  :: line

!-------------------------------------------------------------------------BEGIN

      write(*,*) '*************************************************************'
      write(*,*) 'ERROR'
      write(*,*) ' '
      write(*,*) routine, ': ', message
      write(*,*) ' '
      write(*,*) '           File: ', fich
      write(*,*) '           Line: ', line
      write(*,*) ' '
      write(*,*) '*************************************************************'
      STOP 'ERROR'

!---------------------------------------------------------------------------END
      
      END subroutine ERROR

!===============================================================================
!     NAME: rrhdf5_init
!     AUTHOR: Manel Perucho
!===============================================================================


      SUBROUTINE rrhdf5_init(H_openr, H_opend)

      use hdf5
      USE constantes
      USE parallel
      USE tipos
      USE workarrays  
      
#if defined(PARALELO) && defined(MN) 
  USE mpi
#endif
  IMPLICIT NONE
#if defined(PARALELO) && !defined(MN)
      include "mpif.h"
#endif
#      include "types.h"
#ifdef PARALELO
      integer  ierror
#endif
      integer :: error, H_openr, H_opend

      call h5open_f(error)
      H_openr = 0
      H_opend = 0
      RETURN

      END SUBROUTINE rrhdf5_init 

!===============================================================================
!     NAME: rrhdf5_init
!     AUTHOR: Manel Perucho
!===============================================================================

      SUBROUTINE snapshot_count(outRoot, rstfil, sz)
         IMPLICIT NONE
     
         character(*), intent(in)  :: outRoot    ! Root output directory
         character(7), intent(in)  :: rstfil     ! Snapshot file identifier
         integer, intent(out)      :: sz         ! Number of snapshot files
     
         character(len=1024) :: command      ! Shell command to list files
         character(len=512)  :: filepath, tmpfile  ! File path and temp file
         integer             :: iunit, ios   ! I/O unit and status
     
         tmpfile = 'snapshot_tmp_list.txt'  ! Temporary file to store the list
     
         ! Construct the filepath pattern using wildcard
         filepath = TRIM(outRoot) // TRIM(rstfil) // '-*.h5'
     
         ! Use shell command to list files matching the pattern and save to tmpfile
         command = 'ls -1 ' // TRIM(filepath) // ' > ' // TRIM(tmpfile) // ' 2>/dev/null'
         call execute_command_line(TRIM(command))
     
         ! Open and count the number of lines (i.e., files)
         open(newunit=iunit, file=TRIM(tmpfile), status='old', action='read', iostat=ios)
         if (ios /= 0) then
             sz = 0  ! If no files are found, set sz to 0
             return
         end if
     
         sz = 0
         do
             read(iunit, '(A)', iostat=ios)
             if (ios /= 0) exit
             sz = sz + 1  ! Increment count for each file found
         end do
         close(iunit)
     
         ! Clean up the temporary file
         call execute_command_line('rm -f ' // TRIM(tmpfile))
     
     END SUBROUTINE snapshot_count

!===============================================================================
